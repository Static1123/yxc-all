5.1 什么是事务

　　事务逻辑上的一组操作,组成这组操作的各个逻辑单元,要么一起成功,要么一起失败。

5.2 事务特性

　● 原子性（Atomicity）：操作这些指令时，要么全部执行成功，要么全部不执行。只要其中一个指令执行失败，所有的指令都执行失败，数据进行回滚，回到执行指令前的数据状态。

eg：拿转账来说，假设用户A和用户B两者的钱加起来一共是20000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是20000，这就是事务的一致性。

　　● 一致性（Consistency）：事务的执行使数据从一个状态转换为另一个状态，但是对于整个数据的完整性保持稳定。

　　● 隔离性（Isolation）：隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

　　　　　　　　　　　　  即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。

　　● 持久性（Durability）：当事务正确完成后，它对于数据的改变是永久性的。

5.3 如果不考虑隔离性而引发的问题

　　● 脏读 :一个事务读到了另一个事务的未提交的数据。

　　● 不可重复读 :一个事务读到了另一个事务已经提交的 update 的数据导致多次查询结果不一致。

　　● 虚幻读 :一个事务读到了另一个事务已经提交的 insert 的数据导致多次查询结果不一致。

5.4 解决读问题：设置事务隔离级别

　　事务的隔离级别有4种，由低到高分别为Read uncommitted 、Read committed 、Repeatable read 、Serializable 。而且，在事务的并发操作中可能会出现脏读，不可重复读，幻读。下面通过事例一一阐述它们的概念与联系。

Read uncommitted（最低级别，任何情况都无法保证。）

读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。

eg：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。

Analyse：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读。

那怎么解决脏读呢？Read committed！读提交，能解决脏读问题。



Read committed（可避免脏读的发生。）

读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。

eg：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的…

Analyse：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。

那怎么解决可能的不可重复读问题？Repeatable read ！



Repeatable read（可避免脏读、不可重复读的发生。）

重复读，就是在开始读取数据（事务开启）时，不再允许修改操作

eg：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（事务开启，不允许其他事务的UPDATE修改操作），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。

Analyse：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。

什么时候会出现幻读？

eg：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。

那怎么解决幻读问题？Serializable！



Serializable（可避免脏读、不可重复读、幻读的发生。） 序列化

Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。

Tips：大多数数据库默认的事务隔离级别是Read committed，比如Sql Server , Oracle。

　　　　Mysql的默认隔离级别是Repeatable read。

Tips：隔离级别的设置只对当前链接有效。对于使用MySQL命令窗口而言，一个窗口就相当于一个链接，当前窗口设置的隔离级别只对当前窗口中的事务有效；对于JDBC操作数据库来说，一个Connection对象相当于一个链接，而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他链接Connection对象无关。

Tips：设置数据库的隔离级别一定要是在开启事务之前。


五、Spring进行事务管理一组API

5.1 PlatformTransactionManager:平台事务管理器

真正管理事务的对象：

　　● JDBC 或 iBatis 进行持久化数据时使用　　org.springframework.jdbc.datasource.DataSourceTransactionManager　　

　　● Hibernate 版本进行持久化数据时使用　　org.springframework.orm.hibernate3.HibernateTransactionManager　

5.2 TransactionDefinition:事务定义信息

事务定义信息：

　　● 隔离级别

　　● 传播行为

　　● 超时信息

　　● 是否只读

5.3 事务的传播行为

PROPAGION_XXX ：事务的传播行为

● 保证同一个事务中

　　PROPAGATION_REQUIRED：支持当前事务，如果不存在 就新建一个(默认)

　　PROPAGATION_SUPPORTS ：支持当前事务，如果不存在，就不使用事务

　　PROPAGATION_MANDATORY ：支持当前事务，如果不存在，抛出异常

● 保证没有在同一个事务中

　　PROPAGATION_REQUIRES_NEW：如果有事务存在，挂起当前事务，创建一个新的事务

　　PROPAGATION_NOT_SUPPORTED： 以非事务方式运行，如果有事务存在，挂起当前事务

　　PROPAGATION_NEVER ：以非事务方式运行，如果有事务存在，抛出异常

　　PROPAGATION_NESTED：如果当前事务存在，则嵌套事务执行